
Require Import ZArith.
Local Open Scope Z_scope.


Section Part1.

Inductive maybe (A : Type) : Type :=
  | defined : A -> maybe A
  | undefined : maybe A.

Check maybe.
Print maybe.
Check maybe_ind.

Variables A B : Type.

Definition maybe_apply (f : A -> B) (ma : maybe A) : maybe B :=
  match ma with
  | defined a => defined _ (f a)
  | undefined => undefined B
  end.

Print bool.

Definition is_defined (ma : maybe A) : bool :=
  match ma with
  | defined _ => true
  | undefined => false
  end.

Lemma bool_elim : forall (b : bool),
  b = true \/ b = false.
Proof.
  intro b. destruct b as [ | ].
   left. reflexivity.
   right. reflexivity.
Qed.

Lemma true_neq_false : ~ true = false.
Proof.
  discriminate.
Qed.

Lemma is_defined_exists_defined : forall (ma : maybe A),
  is_defined ma = true -> exists (a : A),
  ma = defined A a.
Proof.
  intros ma E. destruct ma as [a | ].
   exists a. reflexivity.
   simpl in E. discriminate E.
Qed.

End Part1.

Check maybe_apply.


Section Part2.

(* Dichotomic research on [Z]. *)

Check Z.
Check Zdiv.

Variable Array : Type -> Z -> Type.
Variable Array_read : forall A n, Array A n -> Z -> maybe A.
Hypothesis Array_read_ok : forall A n m (a : Array A n),
  m < n -> is_defined _ (Array_read _ _ a m) = true.

Check Array_read_ok.


Inductive state : Type :=
  | state_cons : forall n,
    Z (* goal *) -> Array Z n -> Z (* min *) -> Z (* max *) -> state.


Definition is_final (s : state) : Prop :=
  match s with
  | state_cons _ _ a min max =>
    min = max
  end.

Definition next (s : state) : maybe state :=
  match s with
  | state_cons _ goal a min max =>
    let middle := (min + max) / 2 in
    maybe_apply _ _ (fun vmiddle =>
      if vmiddle <? goal then
        state_cons _ goal a middle max
      else
        state_cons _ goal a min middle)
     (Array_read _ _ a middle)
  end.


Lemma always_in_bounds : forall n goal (a : Array Z n) min max,
  min < n -> max < n ->
  exists min' max',
  min' < n /\ max' < n /\
  next (state_cons _ goal a min max) =
    defined _ (state_cons _ goal a min' max').
Proof.
  intros n goal a min max Imin Imax. simpl.
  assert (Isum : (min + max) / 2 < n).
    apply Zdiv_lt_upper_bound.
     auto with zarith.
    auto with zarith.
  assert (IsDef := Array_read_ok _ _ _ a Isum).
  apply is_defined_exists_defined in IsDef.
  destruct IsDef as [elem Read].
  rewrite Read. simpl.
  destruct (elem <? goal).
    exists ((min + max) / 2). exists max. split.
     apply Isum.
     split.
      apply Imax.
      reflexivity.
    exists min. exists ((min + max) / 2). split.
     apply Imin.
     split.
      apply Isum.
      reflexivity.
Qed.

Print always_in_bounds.

End Part2.


Section Part3.

Require Import Omega.

Check Z.
Check Zdiv.

Variable Array : Type -> Z -> Type.
Variable Array_read : forall A n, Array A n -> Z -> maybe A.
Hypothesis Array_read_ok : forall A n m (a : Array A n),
  m < n -> is_defined _ (Array_read _ _ a m) = true.

Check Array_read_ok.

Variable Array_read_default : forall A, A -> forall n, Array A n -> Z -> A.
Hypothesis Array_read_default_correct : forall A d n m (a : Array A n),
  m < n -> Array_read _ _ a m = defined _ (Array_read_default _ d _ a m).

SearchAbout Zdiv.

Lemma reduce_div_le : forall a b c,
  0 < c ->
  a * c <= b ->
  a <= b / c.
Proof.
  intros a b c Pc I.
  rewrite <- (Z_div_mult_full a c).
   apply Z_div_le; auto with zarith.
   auto with zarith.
Qed.
Hint Resolve reduce_div_le.

Lemma reduce_div_lt : forall a b c,
  0 < c ->
  a <= (c - 1) * b ->
  a / b < c.
Proof.
  intros a b c Pc I.
  Zle_lt_succ
  apply Znot_ge_lt. intro H.
   auto with zarith.
   rewrite <- (Z_div_mult_full c b) in H.
    apply Z_div_le; auto with zarith.
    auto with zarith.
Qed.
Hint Resolve reduce_div_le.


(* Here is a goal generated by Why3 (and changed a little for simplicity). *)

Theorem WP_parameter_dichotomic_sort : forall (a:Z) (n:Z), ((0%Z <
  a)%Z /\ ((0%Z <= n)%Z /\ (n = a))) -> ((0%Z <= (a - 1%Z)%Z)%Z ->
  forall (a1:(Array Z a)), (forall (i:Z), ((0%Z <= i)%Z /\ (i <= (a -
  1%Z)%Z)%Z) -> (((0%Z < a)%Z /\ ((0%Z <= i)%Z /\ (i < a)%Z)) /\
  ((((0%Z <= 0%Z)%Z /\ (0%Z < a)%Z) /\ ((0%Z <= i)%Z /\ (i < a)%Z))
  /\ forall (right1:Z) (left1:Z), (((0%Z <= left1)%Z /\ (left1 <
  a)%Z) /\ ((0%Z <= right1)%Z /\ (right1 < a)%Z)) -> (((left1 <
  right1)%Z -> (((0%Z <= (Zdiv (left1 + right1)%Z 2%Z))%Z /\ ((Zdiv
  (left1 + right1)%Z 2%Z) < a)%Z) /\ ((((Array_read_default _ 0 _ a1
  i) < (Array_read_default _ 0 _ a1 (Zdiv (left1 + right1)%Z 2%Z)))%Z
  -> forall (right2:Z), (right2 = (Zdiv (left1 + right1)%Z 2%Z)) ->
  ((((0%Z <= left1)%Z /\ (left1 < a)%Z) /\ ((0%Z <= right2)%Z /\
  (right2 < a)%Z)) /\ ((0%Z <= (right1 - left1)%Z)%Z /\ ((right2 -
  left1)%Z < (right1 - left1)%Z)%Z))) /\ ((~ ((Array_read_default _ 0
  _ a1 i) < (Array_read_default _ 0 _ a1 (Zdiv (left1 + right1)%Z
  2%Z)))%Z) -> forall (left2:Z), (left2 = ((Zdiv (left1 + right1)%Z
  2%Z) + 1%Z)%Z) -> ((((0%Z <= left2)%Z /\ (left2 < a)%Z) /\ ((0%Z <=
  right1)%Z /\ (right1 < a)%Z)) /\ ((0%Z <= (right1 - left1)%Z)%Z /\
  ((right1 - left2)%Z < (right1 - left1)%Z)%Z)))))) /\ ((~ (left1 <
  right1)%Z) -> ((left1 = right1) /\ ((0%Z <= (i - left1)%Z)%Z ->
  forall (j:Z), ((0%Z <= j)%Z /\ (j <= (i - left1)%Z)%Z) -> ((0%Z <
  a)%Z /\ (((0%Z <= (i - j)%Z)%Z /\ ((i - j)%Z < a)%Z) /\ ((0%Z <=
  ((i - j)%Z + 1%Z)%Z)%Z /\ (((i - j)%Z + 1%Z)%Z < a)%Z)))))))))) /\
  (0%Z < a)%Z).
Proof.
  repeat split; auto with zarith.
  auto with zarith.
  apply reduce_div_le; auto with zarith.



End Part3.



